# 基础部分

# 一、HTML 5 有哪些新标签？

纯记忆型题目，记住不要提自己不熟悉的标签，因为很可能会变成下一道题。

文章相关：header main footer nav section article figure mark

多媒体相关：video audio svg canvas

表单相关：type=email type=tel

MDN 把所有标签都列在[这里](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element)了，且有教程

> 切记：不要给自己挖坑，不要说自己说不清楚的名词
# 二、CSS
## BFC 是什么

答题思路还是「是什么、怎么做、解决了什么问题、优点是、缺点是、怎么解决缺点」

**是什么：**

避免回答，直接把 BFC 翻译成中文「块级格式化上下文」即可，千万别解释。

**怎么做：**

背诵 BFC 触发条件，虽然 [MDN 的这篇文章](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context) 列举了所有触发条件，但本押题告诉你只用背这几个就行了

- 浮动元素（元素的 float 不是 none）

- 绝对定位元素（元素的 position 为 absolute 或 fixed）

- 行内块 inline block 元素

- overflow 值不为 visible 的块元素

- 弹性元素（display为 flex 或 inline-flex元素的直接子元素）

**解决了什么问题：**

1. 清除浮动（为什么不用 .clearfix 呢？）

1. 防止 margin 合并

1. 某些古老的布局方式会用到（已过时）

**优点：**无。

**缺点：**有副作用。

**怎么解决缺点：**使用最新的 `display: flow-root` 来触发 BFC 就没有副作用了，但是很多人不知道。

## 如何实现垂直居中？

> 得分点：flex 方案、grid 方案、transform 方案……

https://juejin.cn/post/7156505305445040142

1. flex

2. margin:auo法

```
.parent{
  height: 600px;
  border: 1px solid red;
  position: relative;
}
.child{
  border: 1px solid green;
  position: absolute;
  width: 300px;
  height: 200px;
  margin: auto;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}
```

3. margin负宽高一半

```
.parent{
  height: 600px;
  border: 1px solid red;
  position: relative;
}
.child{
  border: 1px solid green;
  width: 300px;
  height: 100px;
  position: absolute;
  top: 50%;
  left: 50%;
  margin-left: -150px;
  margin-top: -50px;
}
```

4. translate -50%（与方法3类似）

```
.parent{
  height: 600px;
  border: 1px solid red;
  position: relative;
}
.child{
  border: 1px solid green;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%,-50%);
}
```

## CSS 选择器优先级如何确定？

建议写博客总结，面试甩链接，这样就不用自己背了。

这里有 CSS 2.1 规格文档的权威算法：（但并不适用于 CSS 3）

http://www.ayqy.net/doc/css2-1/cascade.html#specificity

如果记不住，可以记下这三句话：

1. 选择器越具体，其优先级越高

1. 相同优先级，出现在后面的，覆盖前面的

1. 属性后面加 !important 的优先级最高，但是要少用

## 如何清除浮动？

实践题，建议写博客，甩链接。

方法一，给父元素加上 .clearfix

```
.clearfix:after{
     content: '';
     display: block; /*或者 table*/
     clear: both;
 }
 .clearfix{
     zoom: 1; /* IE 兼容*/
 }
```

方法二，给父元素加上 overflow:hidden。

## 两种盒模型（box-sizing）的区别？

答题思路为：先说一，再说二，再说相同点，最后说不同点。

第一种盒模型是 content-box，即 width 指定的是 content 区域宽度，而不是实际宽度，公式为

> 实际宽度 = width + padding + border

第二种盒模型是 border-box，即 width 指定的是左右边框外侧的距离，公式为

> 实际宽度 = width

相同点是都是用来指定宽度的，不同点是 border-box 更好用。

# 三、JS基础

## 1. JS 的数据类型有哪些？

纯记忆题，答案有 8 个词，建议背诵 10 次。

字符串、数字、布尔、undefined、null、大整数、符号、对象

string、number、boolean、undefined、null、bigint、symbol、object

> 提了就零分的答案有：数组、函数、日期。这些是类 class，不是类型 type

## 2.原型链是什么？

**大概念题**，答题思路为大概念化成小概念（分割），抽象化成具体（举例）。

我的答题思路如下：

哦，原型链涉及到的概念挺多的，**我举例说明一下吧**。

假设我们有一个**普通**对象 `x={}`，这个 `x` 会有一个隐藏属性，叫做 `__?????__` ，这个属性会指向 `Object.prototype` ，即

```
x.__?????__ === Object.prototype // 原型
```

此时，我们说 `x 的原型` 是 Object.prototype，或者说 Object.prototype 是 x 的原型。

而这个 `__?????__` 属性的唯一作用就是用来指向 x 的原型的。

如果没有 `__?????__` 属性，x 就不知道自己的原型是谁了。

> 为什么我用问号来表示？因为这样你不容易晕。

接下来我来说说原型链，我还是举例说明吧。

假设我们有一个数组对象 `a=[]` ，这个 `a` 也会有一个隐藏属性，叫做 `__?????__` ，这个属性会指向 `Array.prototype` ，即

```
a.__?????__ === Array.prototype
```

此时，我们说 a 的原型是 `Array.prototype`，跟上面的 x 一样。但又有一点不一样，那就是 Array.prototype 也有一个隐藏属性 `__?????__` ，指向 `Object.prototype` ，即

```
// 用 x 表示 Array.prototype
x.__?????__ === Object.prototype
```

这样一来，a 就有两层原型：

1. a 的原型是 Array.prototype 

1. a 的原型的原型是 Object.prototype 

于是就通过隐藏属性 `__?????__` 形成了一个链条：

```
a ===> Array.prototype ===> Object.prototype 
```

这就是原型链。

以上我对「原型链是什么」的回答。

**怎么做：**

看起来只要改写 x 的隐藏属性 `__?????__` 就可以改变 x 的原型（链）

```
x.__?????__ = 原型
```

但是这不是标准推荐的写法，为了设置 `x.__?????___`，推荐的写法是

```
const x = Object.create(原型)
// 或
const x = new 构造函数() // 会导致 x.__?????__ === 构造函数.prototype
```

> 没错，JS 就是这么别扭。

**解决了什么问题：**

在没有 Class 的情况下实现「继承」。以 `a ===> Array.prototype ===> Object.prototype`  为例，我们说：

1. a 是 Array 的实例，a 拥有 Array.prototype 里的属性

1. Array 继承了 Object（注意专业术语的使用）

1. a 是 Object 的间接实例，a 拥有 Object.prototype 里的属性

这样一来，a 就既拥有 Array.prototype 里的属性，又拥有 Object.prototype 里的属性。

**优点：**

简单、优雅。

**缺点：**

跟 class 相比，不支持私有属性。

**怎么解决缺点：**

使用 class 呗。但 class 是 ES6 引入的，不被旧 IE 浏览器支持。

建议熟读：https://www.zhihu.com/question/56770432/answer/315342130

## 3.this是什么

把判断依据背下来才能全对

```
var length = 4;
function callback() {
  console.log(this.length); // => 打印出什么？
}

const obj = {
  length: 5,
  method(callback) {
    callback();
  }
};

obj.method(callback, 1, 2);
```

建议熟读：https://zhuanlan.zhihu.com/p/23804247

## 4.JS 的 new 做了什么？

记忆题，建议博客，甩链接

1. 创建临时对象/新对象

1. 绑定原型

1. 指定 this = 临时对象

1. 执行构造函数

1. 返回临时对象

   建议熟读：https://zhuanlan.zhihu.com/p/23987456

## 5.立即执行函数是什么？

概念题，「是什么、怎么做、解决了什么问题、优点是、缺点是、怎么解决缺点」

**是什么：**

声明一个匿名函数，然后立即执行它。这种做法就是立即执行函数。

**怎么做：**

```
(function(){alert('我是匿名函数')} ())  // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')}) ()  // 用括号把函数包起来
!function(){alert('我是匿名函数')}()    // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}()
-function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}()
void function(){alert('我是匿名函数')}()
new function(){alert('我是匿名函数')}()
var x = function(){return '我是匿名函数'}()
```

上面每一行代码都是一个立即执行函数。（举例法）

**解决了什么问题：**

**在 ES6 之前**，只能通过它来「创建局部作用域」。

**优点：**

兼容性好。

**缺点：**

丑。为什么这么丑？看视频分析。

**怎么解决缺点：**

使用 ES6 的 block + let 语法，即

```
{
  let a = '我是局部变量啦'
  console.log(a) // 能读取 a
}
console.log(a) // 找不到 a
```

## 6.JS 的闭包是什么？怎么用？

概念题，「是什么、怎么做、解决了什么问题、优点是、缺点是、怎么解决缺点」

**是什么**

闭包是 JS 的一种**语法特性**。

> 闭包 = 函数 + 自由变量

对于一个函数来说，变量分为：全局变量、本地变量、自由变量

**怎么做**

```
  let count
  function add (){ // 访问了外部变量的函数
    count += 1
  }
```

把上面代码放在「非全局环境」里，就是闭包。

> 注意，闭包不是 count，闭包也不是 add，闭包是 count + add 组成的整体。

怎么制造一个「非全局环境」呢？答案是立即执行函数：

```
const x = function (){
	var count
	function add (){ // 访问了外部变量的函数
	  count += 1
	}
}()
```

但是这个代码什么用也没有，所以我们需要 `return add` ，即：

```
const add2 = function (){
	var count
	return function add (){ // 访问了外部变量的函数
	  count += 1
	}
}()
```

此时 add2 其实就是 add，我们可以调用 add2

```
add2()
// 相当于
add()
// 相当于
count += 1
```

至此，我们就实现了一个完整的「闭包的应用」。

> 注意：闭包 ≠ 闭包的应用，但面试官问你「闭包」的时候，你一定要答「闭包的应用」，这是规矩。

**解决了什么问题：**

1. 避免污染全局环境。（因为用的是局部变量）

1. 提供对局部变量的间接访问。（因为只能 count += 1 不能 count -= 1）

1. 维持变量，使其不被垃圾回收。

优点：

简单，好用。

缺点：

闭包**使用不当**可能造成内存泄露。

注意，重点是「使用不当」，不是闭包。

「闭包造成内存泄露」这句话以讹传讹很多年了，曾经旧版本 IE 的 bug 导致的问题，居然被传成这样了。

举例说明：

```
function test() {
  var x = {name: 'x'};
  var y = {name: 'y', content: "-----这里很长，有一万三千五百个字符那么长----" }
  return function fn() {
    return x;
  };
}

const myFn = test() // myFn 就是 fn 了
const myX = myFn() // myX 就是 x 了
// 请问，y 会消失吗？
```

对于一个正常的浏览器来说，y 会在**一段时间**后自动消失（被垃圾回收器给回收掉）。

但旧版本的 IE 并不是正常的浏览器，所以是 IE 的问题。

当然，你可以说

> 君子不立于危墙之下，我们应该尽量少用闭包，因为有些浏览器对闭包的支持不够好

但你不可以说「闭包造成内存泄露」。对吗？

**怎么解决缺点：**

慎用，少用，不用。（我偏要用）

> 建议熟读这篇文章：https://zhuanlan.zhihu.com/p/22486908

## 7.JS 如何实现类？

[方法一：使用原型](#c7afecbe-e670-4f1e-82d0-39f5f1241ca5)

[方法二：使用 class](#2043e7d3-d7de-4cc1-8341-e35748afd51d)

### 方法一：使用原型

```
function Dog(name){ 
  this.name = name
  this.legsNumber = 4
}
Dog.prototype.kind = '狗'
Dog.prototype.say = function(){
  console.log(`汪汪汪~ 我是${this.name}，我有${this.legsNumber}条腿。`)
}
Dog.prototype.run = function(){
  console.log(`${this.legsNumber}条腿跑起来。`)
}
const d1 = new Dog('啸天') // Dog 函数就是一个类
d1.say()
```

请试着实现一个 Chicken 类，没 name 会 say 会 fly。

### 方法二：使用 class

```
class Dog {
  kind = '狗' // 等价于在 constructor 里写 this.kind = '狗'
  constructor(name) {
    this.name = name
    this.legsNumber = 4
    // 思考：kind 放在哪，放在哪都无法实现上面的一样的效果
  }
  say(){
    console.log(`汪汪汪~ 我是${this.name}，我有${this.legsNumber}条腿。`)
  }
  run(){
    console.log(`${this.legsNumber}条腿跑起来。`)
  }
}
const d1 = new Dog('啸天')
d1.say() 
```

请试着实现一个 Chicken 类，没 name 会 say 会 fly。

##  8.如何实现继承？

[方法一：使用原型链](#c808f496-3a03-4b1c-a8ea-83d8e47720d3)

[方法二：使用 class](#e4487ee4-664d-47be-82d8-6e28ad7874e3)

### 方法一：使用原型链

```
function Animal(legsNumber){
  this.legsNumber = legsNumber
}
Animal.prototype.kind = '动物'

function Dog(name){ 
  this.name = name
  Animal.call(this, 4) // 关键代码1
}
Dog.prototype.__proto__ = Animal.prototype // 关键代码2，但这句代码被禁用了，怎么办

Dog.prototype.kind = '狗'
Dog.prototype.say = function(){
  console.log(`汪汪汪~ 我是${this.name}，我有${this.legsNumber}条腿。`)
}

const d1 = new Dog('啸天') // Dog 函数就是一个类
console.dir(d1)
```

如果面试官问被 ban 的代码如何替换，就说下面三句：

```
var f = function(){ }
f.prototype = Animal.prototype
Dog.prototype = new f()
```

### 方法二：使用 class

```
class Animal{
  constructor(legsNumber){
    this.legsNumber = legsNumber
  }
  run(){}
}
class Dog extends Animal{
  constructor(name) {
    super(4)
    this.name = name
  }
  say(){
    console.log(`汪汪汪~ 我是${this.name}，我有${this.legsNumber}条腿。`)
  }
}
```

# 四、JS手写篇

## 手写节流 throttle、防抖 debounce

   记忆题，写博客，甩链接。

   节流：

   ```
// 节流就是「技能冷却中」
const throttle = (fn, time) => {
  let 冷却中 = false
  return (...args) => {
    if(冷却中) return
    fn.call(undefined, ...args)
    冷却中 = true
    setTimeout(()=>{
      冷却中 = false
    }, time)
  }
}
// 还有一个版本是在冷却结束时调用 fn
// 简洁版，删掉冷却中变量，直接使用 timer 代替
const throttle = (f, time) => {
  let timer = null
  return (...args) => {
		if(timer) {return}
		f.call(undefined, ...args)
		timer = setTimeout(()=>{
		  timer = null
		}, time)
  }
}
   ```

   使用方法：

   ```
const f = throttle(()=>{console.log('hi')}, 3000)

f() // 打印 hi
f() // 技能冷却中
   ```

   防抖：

   ```
// 防抖就是「回城被打断」
const debounce = (fn, time) => {
  let 回城计时器 = null
  return (...args)=>{
    if(回城计时器 !== null) {
      clearTimeout(回城计时器) // 打断回城
    }
    // 重新回城
    回城计时器 = setTimeout(()=>{
      fn.call(undefined, ...args) // 回城后调用 fn
      回城计时器 = null
    }, time)
  }
}
   ```

## 手写发布订阅

记忆题，写博客，甩链接

```
const eventHub = {
  map: {
    // click: [f1 , f2]
  },
  on: (name, fn)=>{
    eventHub.map[name] = eventHub.map[name] || []
    eventHub.map[name].push(fn)
  },
  emit: (name, data)=>{
    const q = eventHub.map[name]
    if(!q) return
    q.map(f => f.call(null, data))
    return undefined
  },  
  off: (name, fn)=>{
    const q = eventHub.map[name]
    if(!q){ return }
    const index = q.indexOf(fn)
    if(index < 0) { return }
    q.splice(index, 1)
  }
}

eventHub.on('click', console.log)
eventHub.on('click', console.error)

setTimeout(()=>{
  eventHub.emit('click', 'frank')
},3000)
```

也可以用 class 实现。

```
class EventHub {
  map = {}
  on(name, fn) {
    this.map[name] = this.map[name] || []
    this.map[name].push(fn)
  }
  emit(name, data) {
    const fnList = this.map[name] || []
    fnList.forEach(fn => fn.call(undefined, data))
  }
  off(name, fn) {
    const fnList = this.map[name] || []
    const index = fnList.indexOf(fn)
    if(index < 0) return
    fnList.splice(index, 1)
  }
}
// 使用
const e = new EventHub()
e.on('click', (name)=>{
  console.log('hi '+ name)
})
e.on('click', (name)=>{
  console.log('hello '+ name)
})
setTimeout(()=>{
  e.emit('click', 'frank')
},3000)
```

## 手写 AJAX

记忆题，写博客吧

```
const ajax = (method, url, data, success, fail) => {
  var request = new XMLHttpRequest()
  request.open(method, url);
  request.onreadystatechange = function () {
    if(request.readyState === 4) {
      if(request.status >= 200 && request.status < 300 || request.status === 304) {
        success(request)
      }else{
        fail(request)
      }
    }
  };
  request.send();
}
```

## 手写简化版 Promise

记忆题，写博客吧

```
class Promise2 {
  #status = 'pending'
  constructor(fn){
    this.q = []
    const resolve = (data)=>{
      this.#status = 'fulfilled'
      const f1f2 = this.q.shift()
      if(!f1f2 || !f1f2[0]) return
      const x = f1f2[0].call(undefined, data)
      if(x instanceof Promise2) {
        x.then((data)=>{
          resolve(data)
        }, (reason)=>{
          reject(reason)
        })
      }else {
        resolve(x)
      }
    }
    const reject = (reason)=>{
      this.#status = 'rejected'
      const f1f2 = this.q.shift()
      if(!f1f2 || !f1f2[1]) return
      const x = f1f2[1].call(undefined, reason)
      if(x instanceof Promise2){
        x.then((data)=>{
          resolve(data)
        }, (reason)=>{
          reject(reason)
        })
      }else{
        resolve(x)
      }
    }
    fn.call(undefined, resolve, reject)
  }
  then(f1, f2){
    this.q.push([f1, f2])
  }
}

const p = new Promise2(function(resolve, reject){
  setTimeout(function(){
    reject('出错')
  },3000)
})

p.then( (data)=>{console.log(data)}, (r)=>{console.error(r)} )
```

## 手写 Promise.all

记忆题，写博客吧。

要点：

1. 知道要在 Promise 上写而不是在原型上写

1. 知道 all 的参数（Promise 数组）和返回值（新 Promise 对象）

1. 知道用数组来记录结果

1. 知道只要有一个 reject 就整体 reject

```
Promise.prototype.myAll
Promise.myAll = function(list){
  const results = []
  let count = 0
  return new Promise((resolve,reject) =>{
    list.map((item, index)=> {
      item.then(result=>{
          results[index] = result
          count += 1
          if (count >= list.length) { resolve(results)}
      }, reason => reject(reason) )
    })
  })
}
```

进一步提问：是否知道 Promise.allSettled()

## 手写深拷贝

### 方法一，用 JSON：

```
const b = JSON.parse(JSON.stringify(a))
```

答题要点是指出这个方法有如下缺点：

1. 不支持 Date、正则、undefined、函数等数据

1. 不支持引用（即环状结构）

1. 必须说自己还会方法二

### 方法二，用递归：

要点：

1. 递归

1. 判断类型

1. 检查环

1. 不拷贝原型上的属性

```
const deepClone = (a, cache) => {
  if(!cache){
    cache = new Map() // 缓存不能全局，最好临时创建并递归传递
  }
  if(a instanceof Object) { // 不考虑跨 iframe
    if(cache.get(a)) { return cache.get(a) }
    let result 
    if(a instanceof Function) {
      if(a.prototype) { // 有 prototype 就是普通函数
        result = function(){ return a.apply(this, arguments) }
      } else {
        result = (...args) => { return a.call(undefined, ...args) }
      }
    } else if(a instanceof Array) {
      result = []
    } else if(a instanceof Date) {
      result = new Date(a - 0)
    } else if(a instanceof RegExp) {
      result = new RegExp(a.source, a.flags)
    } else {
      result = {}
    }
    cache.set(a, result)
    for(let key in a) { 
      if(a.hasOwnProperty(key)){
        result[key] = deepClone(a[key], cache) 
      }
    }
    return result
  } else {
    return a
  }
}

const a = { 
  number:1, bool:false, str: 'hi', empty1: undefined, empty2: null, 
  array: [
    {name: 'frank', age: 18},
    {name: 'jacky', age: 19}
  ],
  date: new Date(2000,0,1,20,30,0),
  regex: /\.(j|t)sx/i,
  obj: { name:'frank', age: 18},
  f1: (a, b) => a + b,
  f2: function(a, b) { return a + b }
}
a.self = a

const b = deepClone(a)

b.self === b // true
b.self = 'hi'
a.self !== 'hi' //true
```

## 手写数组去重

1. 使用计数排序的思路，缺点是只支持字符串

1. 使用 Set（面试已经禁止这种了，因为太简单）

1. 使用 Map，缺点是兼容性差了一点

```
var uniq = function(a){
  var map = new Map()
  for(let i=0;i<a.length;i++){
    let number = a[i] // 1 ~ 3
    if(number === undefined){continue}
    if(map.has(number)){
      continue
    }
    map.set(number, true)
    
  }
  return [...map.keys()]
}
```



# 五、HTTP

## 1.GET 和 POST 的区别有哪些？

### 区别一：幂等性

1. 由于 GET 是读，POST 是写，所以 GET 是幂等的，POST 不是幂等的。

1. 由于 GET 是读，POST 是写，所以用浏览器打开网页会发送 GET 请求，想要 POST 打开网页要用 form 标签。

1. 由于 GET 是读，POST 是写，所以 GET 打开的页面刷新是无害的，POST 打开的页面刷新需要确认。

1. 由于 GET 是读，POST 是写，所以 GET 结果会被缓存，POST 结果不会被缓存。

1. 由于 GET 是读，POST 是写，所以 GET 打开的页面可被书签收藏，POST 打开的不行。

### 区别二：请求参数

1. 通常，GET 请求参数放在 url 里，POST 请求数据放在 body（消息体）里。（这里注意老师的讲解）

1. GET 比 POST 更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。（xjb扯）

1. GET 请求参数放在 url 里是有长度限制的，而 POST 放在 body 里没有长度限制。（xjb扯）

### 区别三：TCP packet

1. GET 产生一个 TCP 数据包；POST 产生两个或以上 TCP 数据包。



⚠️

根据技术规格文档，GET 和 POST 最大的区别是语义；但面试官一般问的是实践过程中二者的区别，因此你需要了解服务器和浏览器对 GET 和 POST 的常见实现方法。

## 2.HTTP 缓存有哪些方案？

|          | 缓存（强缓存）                                               | 内容协商（弱缓存）                                           |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| HTTP 1.1 | Cache-Control: max-age=3600 Etag: ABC                        | If-None-Match: ABC 响应状态码：304 或 200                    |
| HTTP 1.0 | Expires: Wed, 21 Oct 2015 02:30:00 GMT Last-Modified: Wed, 21 Oct 2015 01:00:00 GMT | If-Modified-Since: Wed, 21 Oct 2015 01:00:00 GMT 响应状态码：304 或 200 |

面试官可能还会提到 `Pragma` ，但 MDN 已经明确不推荐使用它。

更详细的内容可以看我的课程《[全面攻克 Web 性能优化](https://xiedaimala.com/courses/b65a6488-4038-4676-932e-ae125613ad69)》中的《[缓存与内容协商](https://xiedaimala.com/tasks/9d8708a7-7a70-4ae1-a4e9-207f59df15be)》视频。

## 3.HTTP 和 HTTPS 的区别有哪些？

⚠️HTTPS = HTTP + SSL/TLS（安全层）

区别列表

1. HTTP 是明文传输的，不安全；HTTPS 是加密传输的，非常安全。

1. HTTP 使用 80 端口，HTTPS 使用 443 端口。

1. HTTP 较快，HTTPS 较慢。

1. HTTPS 的证书一般需要购买（但也有免费的），HTTP 不需要证书。



HTTPS 的细节可以看网上的博客，比较复杂，难以记忆，建议写博客总结一下。

[图解SSL/TLS协议 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html) 

[HTTPS原理以及握手阶段

## 4.HTTP/1.1 和 HTTP/2 的区别有哪些？

区别列表

1. HTTP/2 使用了**二进制传输**，而且将 head 和 body 分成**帧**来传输；HTTP/1.1 是字符串传输。

1. HTTP/2 支持**多路复用**，HTTP/1.1 不支持。多路复用简单来说就是一个 TCP 连接从单车道（不是单行道）变成了几百个双向通行的车道。

1. HTTP/2 可以**压缩 head**，但是 HTTP/1.1 不行。

1. HTTP/2 支持**服务器推送**，但 HTTP/1.1 不支持。（实际上没多少人用）

更详细的内容可以看我的课程《[全面攻克 Web 性能优化](https://xiedaimala.com/courses/b65a6488-4038-4676-932e-ae125613ad69)》中的《[什么是多路复用](https://xiedaimala.com/tasks/66bb6c5f-8026-4953-951c-edfd6c3f64b3)》视频。[](https://juejin.cn/post/6844903892765900814)

## 5.TCP 三次握手和四次挥手是什么？

### 5.1建立 TCP 连接时 server 与 client 会经历三次握手

1. 浏览器向服务器发送 TCP 数据：SYN(seq=x)

1. 服务器向浏览器发送 TCP 数据：ACK(seq=x+1) SYN(y)

1. 浏览器向服务器发送 TCP 数据：ACK(seq=y+1)

### 5.2关闭 TCP 连接时 server 与 client 会经历四次挥手

1. 浏览器向服务器发送 TCP 数据：FIN(seq=x)

1. 服务器向浏览器发送 TCP 数据：ACK(seq=x+1)

1. 服务器向浏览器发送 TCP 数据：FIN(seq=y)

1. 浏览器向服务器发送 TCP 数据：ACK(seq=y+1)

为什么 2、3 步骤不合并起来呢？看起来是脱裤子放屁。

答案：2、3 中间服务器很可能还有数据要发送，不能提前发送 FIN。

## 6.说说同源策略和跨域

### 6.1同源策略是什么？

如果两个 URL 的协议、端口和域名都完全一致的话，则这两个 URL 是同源的。

```
http://www.baidu.com/s 
http://www.baidu.com:80/ssdasdsadad
```

### 6.2同源策略怎么做？

只要在**浏览器**里打开页面，就默认遵守同源策略。 

#### 优点

保证用户的隐私安全和数据安全。

#### 缺点

很多时候，前端需要访问另一个域名的后端接口，会被浏览器阻止其获取响应。

比如甲站点通过 AJAX 访问乙站点的 /money 查询余额接口，请求会发出，但是响应会被浏览器屏蔽。

## 7.跨域
怎么解决缺点——使用跨域手段
### 7.1  JSONP（前端体系课有完整且详细的介绍）

   1. 甲站点利用 script 标签可以跨域的特性，向乙站点发送 get 请求。

   1. 乙站点**后端改造** JS 文件的内容，将数据传进回调函数。

   1. 甲站点通过回调函数拿到乙站点的数据。

### 7.2 CORS（前端体系课有完整且详细的介绍）

   1. 对于简单请求，乙站点在响应头里添加 `Access-Control-Allow-Origin: http://甲站点` 即可。

   1. 对于复杂请求，如 PATCH，乙站点需要：

      1. 响应 OPTIONS 请求，在响应中添加如下的响应头

         ```
         Access-Control-Allow-Origin: https://甲站点
         Access-Control-Allow-Methods: POST, GET, OPTIONS, PATCH
         Access-Control-Allow-Headers: Content-Type
         ```

      1. 响应 POST 请求，在响应中添加 `Access-Control-Allow-Origin` 头。

   1. 如果需要附带身份信息，JS 中需要在 AJAX 里设置 `xhr.withCredentials = true` 。

1. Nginx 代理 / Node.js 代理
   1. 前端 ⇒ 后端 ⇒ 另一个域名的后端

详情参考 [MDN CORS 文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)。

## 8.Session、Cookie、LocalStorage、SessionStorage 的区别

- Cookie V.S. LocalStorage

  1. 主要区别是 **Cookie** 会被发送到**服务器**，而 LocalStorage 不会

  1. Cookie 一般最大 4k，LocalStorage 可以用 5Mb 甚至 10Mb（各浏览器不同）

- LocalStorage V.S. SessionStorage

  1. LocalStorage 一般不会自动过期（除非用户手动清除）

  1. SessionStorage 在回话结束时过期（如关闭浏览器之后，具体由浏览器自行决定）

- Cookie V.S. Session

  1. **Cookie 存在浏览器**的文件里，**Session 存在服务器**的文件里

  1. Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存在 Cookie 里

PS: 其他区别请在网上找高票答案看看，自己写文章总结一下。

# 六、DOM

## 1.请简述 DOM 事件模型

先经历从上到下的捕获阶段，再经历从下到上的冒泡阶段。

addEventListener(’click’,fn,true/false) 第三个参数可以选择阶段。

可以使用 `event.stopPropagation()` 来阻止捕获或冒泡。

## 2.手写事件委托

### 错误版（但是可能能通过面试）

```
 ul.addEventListener('click', function(e){
     if(e.target.tagName.toLowerCase() === 'li'){
         fn()// 执行某个函数
     }
 })
```

bug 在于，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对。

好处：

1. 节省监听器

1. 实现动态监听

坏处：调试比较复杂，不容易确定监听者。（如何解决坏处: 解决不了）

### 高级版（不用背）

思路是点击 span 后，递归遍历 span 的祖先元素看其中有没有 ul 里面的 li。

```
function delegate(element, eventType, selector, fn) {
	element.addEventListener(eventType, e => {
	  let el = e.target
	  while (!el.matches(selector)) {
	    if (element === el) {
	      el = null
	      break
	    }
	    el = el.parentNode
	  }
	  el && fn.call(el, e, el)
	})
	return element
}

delete(ul, 'click', 'li', f1)
```

先经历从上到下的捕获阶段，再经历从下到上的冒泡阶段。

addEventListener(’click’,fn,true/false) 第三个参数可以选择阶段。

可以使用 `event.stopPropagation()` 来阻止捕获或冒泡。

## 3.手写可拖曳 div

参考代码：https://jsbin.com/munuzureya/edit?html,js,output

要点：

1. 注意监听范围，不能只监听 div
1. 不要使用 drag 事件，很难用。
1. 使用 transform 会比 top / left 性能更好，因为可以避免 reflow 和 repaint。

# 高级部分

# 二、Vue 2

## 1. Vue 2 的生命周期钩子有哪些？数据请求放在哪个钩子？

Vue 2 文档写得很清楚，红色空心框中的文字皆为生命周期钩子：

1. create x 2 (before + ed) - SSR

1. mount x 2

1. update x 2

1. destroy x 2

还有三个写在[钩子列表](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)里：

1. activated

1. deactivated

1. errorCaptured

请求放在 mounted 里面，因为放在其他地方都不合适（xjb扯）。

### 其他版本：

vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom一›渲染、更新一渲染、卸载等一系列过程。

vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。

1. beforecreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。

2. created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。

  一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。

3. beforemount 钩子函数，在组件被挂载到页面之前触发。在 beforemount之前，会找到对应的template，并编译成render 函数。
4. mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API **获取到页面中的 DOM元素**，
5. beforeupdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如**移除事件监听器**。
6. updated 钩子函数，虚拟DOM 重新渲染和打补丁之后调用。
7. beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以**销毁定时器、解绑全局事件**等。
8. destroved 钩子函数，在实例销毁之后调用，调用后， vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁
9. 当我们使用 keep-alive 的时候，还有两个钩子函数，分别是activated 和deactivated。用keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行deactivated 钩子函数，**命中缓存渲染后**会执行actived 钩子函数。
10. 如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。

## 其他版本2

**创建期**

 当我们创建组件的时候（如在页面中使用），组件将执行创建期的方法，

1. **beforeCreate** 组件创建前，此时**数据，事件等还没有初始化**
2. **created** 组件创建后，此时组件**已经绑定了数据，事件**等
3. **beforeMount** 组件构建前，此时确定了**组件的模板，以及渲染的容器元素**等。
4. **mounted** 组件构建后，此时**组件上树了**

 **一个组件在一生中只能创建一次，因此创建期的方法只能执行一次。**

 一旦组件的**模型数据发生改变**，**组件**将会执行**存在期的方法**

**存在期**

当组件**创建完成，将进入存在期，**共分**两个阶段**：

- **beforeUpdate**     **组件更新前**，此时**数据改变了，视图尚未更新**
- **updated** 组件更新后，此时**数据和视图都更新了**

 在一个组件中，我们可以不停的改变模型数据，因此**存在期的方法会不停的执行。**

 **存在期的方法执行完毕，只是说一次更新的结束，存在期仍然继续。**



**销毁期**

当组件从页面中**删除（执行了$destroy方法）**,组件将**进入销毁期，执行销毁期的方法**，共分**两个阶段：**

- **beforeDestroy**     **组件销毁期**，此时**组件中**的**数据等还有监听器**。
- **destroyed**     **组件销毁后**，此时组件的**数据所具有的****监听器以及子组件****等被销毁了。**

 一旦组件被销毁，我们就再也无法使用组件了，想使用只能创建新的组件了。

**以上周期方法this都指向组件实例，没有参数**



## 2. Vue 2 组件间通信方式有哪些？

1. 父子组件：使用「props 和事件」进行通信

2. 爷孙组件：

   1. 使用两次父子组件间通信来实现

   2. 使用「provide + inject」来通信

3. 任意组件：使用 eventBus = new Vue() 来通信

   1. 主要API 是 eventBus.$on 和 eventBus.$emit

   2. 缺点是事件多了就很乱，难以维护

4. 任意组件：使用 Vuex 通信（Vue 3 可用 Pinia 代替 Vuex）

## 3. Vuex 用过吗？怎么理解？

1. 背下文档第一句：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库

2. 说出核心概念的名字和作用：store/State/Getter/Mutation/Action/Module

   1. store 是个大容器，包含以下所有内容

   2. State 用来读取状态，带有一个 mapState 辅助函数

   3. Getter 用来读取派生状态，附有一个 mapGetters 辅助函数

   4. Mutation 用于同步提交状态变更，附有一个 mapMutations 辅助函数

   5. Action 用于异步变更状态，但它提交的是 mutation，而不是直接变更状态。

   6. Module 用来给 store 划分模块，方便维护代码

常见追问：Mutation 和 Action 为什么要分开？

答案：为了让代码更易于维护。（可是 Pinia 就把 Mutation 和 Action 合并了呀）

完。

## 4. VueRouter 用过吗？怎么理解？

1. 背下文档第一句：Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。

1. 说出核心概念的名字和作用：`router-link` `router-view` 嵌套路由、Hash 模式和 History 模式、导航守卫、懒加载

1. 常见追问：

   1. Hash 模式和 History 模式的区别？

      1. 一个用的 Hash，一个用的 History API

      1. 一个不需要后端 nginx 配合，一个需要

   1. 导航守卫如何实现登录控制？

      ```
      router.beforeEach((to, from, next) => {
        if (to.path === '/login') return next()
        if (to是受控页面 && 没有登录) return next('/login')
        next()
      })
      ```

推荐阅读：https://blog.csdn.net/sinat_36521655/article/details/106125910

**vue-router中的导航钩子函数**

1. **全局的**钩子函数 **beforeEach** 和**afterEach**
2. beforeEach 有三个参数， **to** 代表要进入的路由对象，**from** 代表离开的路由对象。**next** 是一个必须要执行的函数，
  1. 如果不传参数，那就执行下一个钩子函数，
  2. 如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，
  3. 如果传入error，则导航终止，error 传入错误的监听函数
3. 单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。
4. **组件内**的导航钩子主要有这三种： **beforeRouteEnter**、 **beforeRouteupdate**、**beforeRouteLeave**它们是直接在路由组件内部直接进行定义的。

## 5. Vue 2 是如何实现双向绑定的？

推荐阅读：https://www.cnblogs.com/canfoo/p/6891868.html

通过 Object.defineProperty(来劫持各个属性的setter / getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

1. 说明一般使用 

   `v-model`/ `.sync`实现，`v-model` 是 `v-bind:value`和`v-on:input`的语法糖

   1. `v-bind:value` 实现了 data ⇒ UI 的单向绑定

   1. `v-on:input` 实现了 UI ⇒ data 的单向绑定

   1. 加起来就是双向绑定了

1. 这两个单向绑定是如何实现的呢？

   1. 前者通过 Object.defineProperty API 给 data 创建 getter 和 setter，用于监听 data 的改变，data 一变就会安排改变 UI

   1. 后者通过 template compiler 给 DOM 添加事件监听，DOM input 的值变了就会去修改 data。

网上的博客讲得很绕，你可以尝试理解看看。

## 6. computed 与 watch
1. computed 是计算一个新的属性，并将该属性挂载到 vue 实例上，而watch 是监听已经存在且已挂载到 vue 实例上的数据，所以用 watch 同样可以监听computed 计算属性的变化。
2. computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问computed属性，才会计算新的值。而watch 则是当数据发生变化便会调用执行函数。
3. 从使用场景上说，computed 适用一个数据被多个数据影晌，而watch 适用一个数据影响多个数据。
4. 二者区别：computed 是计算属性，依赖其他属性计算值，并且computed 的值有缓存，只有当计算值变化才会返回内容。
   watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。

## 7. 父子通信

1.父子组件间通信

  * 第一种方法是子组件通过 **props** 属性来接受父组件的数据，然后父组件在子组件上注明监听事件，子组件通过 **emit** 触发事件来向父组件发送数据。

  * 第二种是通过**ref 属性**给子组件设置一个名字，父组件通过 **$refs** 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。

  * 第三种是使用 provider / inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件 中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。

2.兄弟组件间通信
    第一种是使用 **eventBus** 的方法，它的本质是通过创建一个空的 vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。

​	第二种是通过 **$parent.$refs** 来获取到兄弟组件，也可以进行通信。

3.任意组件之门
    使用 eventBus，其实就是创建一个事件中心

# 三、Vue3

## Vue 3 为什么使用 Proxy？
1. 弥补 Object.defineProperty 的两个不足

   1. 动态创建的 data 属性需要用 Vue.set 来赋值，Vue 3 用了 Proxy 就不需要了

   1. 基于性能考虑，[Vue 2 篡改了数组的 7 个 API](https://cn.vuejs.org/v2/guide/list.html#变更方法)，Vue 3 用了 Proxy 就不需要了

1. defineProperty 需要提前递归地遍历 data 做到响应式，而 Proxy 可以在真正用到深层数据的时候再做响应式（惰性）

## Vue 3 为什么使用 Composition API？
答案参考尤雨溪的博客：[Vue Function-based API RFC - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/68477600)

1. Composition API 比 mixins、高阶组件、extends、Renderless Components 等更好，原因有三：

   1. 模版中的数据来源不清晰。

   1. 命名空间冲突。

   1. 性能。

2. 更适合 TypeScript

## Vue 3 对比 Vue 2 做了哪些改动？
   [官方文档](https://v3-migration.vuejs.org/breaking-changes/)写了（[中文在这](https://v3.cn.vuejs.org/guide/migration/introduction.html#非兼容的变更)），这里列出几个容易被考的：

   1. createApp() 代替了 new Vue()

   1. v-model 代替了以前的 v-model 和 .sync

   1. 根元素可以有不止一个元素了

   1. 新增 Teleport 传送门

   1. destroyed 被改名为 unmounted 了（before 当然也改了）

   1. ref 属性支持函数了

   其他建议自己看看写写。

# 四、React

## 1.虚拟 DOM 的原理是什么？

1. 是什么

   虚拟 DOM 就是虚拟节点（这句汉化很重要）。React 用 JS 对象来**模拟** DOM 节点，然后将其渲染成真实的 DOM 节点。

1. 怎么做

   **第一步是模拟**

   用 JSX 语法写出来的 div 其实就是一个虚拟节点：

   ```
   <div id="x">
     <span class="red">hi</span>
   </div>
   ```

   这代码会得到这样一个对象：

   ```
   {
     tag: 'div',
     props: {
       id: 'x'
     },
     children: [
       {
         tag: 'span',
         props: {
           className: 'red'
         },
         children: [
           'hi'
         ]
       }
     ]
   }
   ```

   能做到这一点是因为 JSX 语法会被转译为 createElement 函数调用（也叫 h 函数），如下：

   ```
   React.createElement("div", { id: "x"}, 
     React.createElement("span", { class: "red" }, "hi")
   )
   ```

   **第二步是将虚拟节点渲染为真实节点**

   ```
   function render(vdom) {
     // 如果是字符串或者数字，创建一个文本节点
     if (typeof vdom === 'string' || typeof vdom === 'number') {
       return document.createTextNode(vdom)
     }
     const { tag, props, children } = vdom
     // 创建真实DOM
     const element = document.createElement(tag)
     // 设置属性
     setProps(element, props)
     // 遍历子节点，并获取创建真实DOM，插入到当前节点
     children
       .map(render)
       .forEach(element.appendChild.bind(element))
   
     // 虚拟 DOM 中缓存真实 DOM 节点
     vdom.dom = element
     
     // 返回 DOM 节点
     return element
   }
   
   function setProps // 略
   function setProp // 略
   
   // 作者：Shenfq
   // 链接：https://juejin.cn/post/6844903870229905422
   ```

   注意，如果节点发生变化，并不会直接把新虚拟节点渲染到真实节点，而是先经过 diff 算法得到一个 patch 再更新到真实节点上。

1. 解决了什么问题

   1. DOM 操作性能问题。通过虚拟 DOM 和 diff 算法减少不必要的 DOM 操作，保证性能不太差

   1. DOM 操作不方便问题。以前各种 DOM API 要记，现在只有 setState

1. 优点

   1. 为 React 带来了跨平台能力，因为虚拟节点除了渲染为真实节点，还可以渲染为其他东西。

   1. 让 DOM 操作的整体性能更好，能（通过 diff）减少不必要的 DOM 操作。

1. 缺点

   1. 性能要求极高的地方，还是得用真实 DOM 操作（目前没遇到这种需求）

   1. React 为虚拟 DOM 创造了

      合成事件

      ，跟原生 DOM 事件不太一样，工作中要额外注意

      1. 所有 React 事件都绑定到根元素，自动实现事件委托

      1. 如果混用合成事件和原生 DOM 事件，有可能会出 bug

1. 如何解决缺点

   不用 React，用 Vue 3（笑）

## 2.React 或 Vue 的 DOM diff 算法是怎样的？

   1. 是什么

      DOM diff 就是对比两棵虚拟 DOM 树的算法（废话很重要）。当组件变化时，会 render 出一个新的虚拟 DOM，diff 算法对比新旧虚拟 DOM 之后，得到一个 patch，然后 React 用 patch 来更新真实 DOM。

   1. 怎么做

      1. 首先对比两棵树的根节点

         1. 如果根节点的类型改变了，比如 div 变成了 p，那么直接认为整棵树都变了，不再对比子节点。此时直接删除对应的真实 DOM 树，创建新的真实 DOM 树。

         1. 如果根节点的类型没变，就看看属性变了没有

            1. 如果没变，就保留对应的真实节点

            1. 如果变了，就只更新该节点的属性，不重新创建节点。
               1. 更新 style 时，如果多个 css 属性只有一个改变了，那么 React 只更新改变的。

      1. 然后同时遍历两棵树的子节点，每个节点的对比过程同上。

         1. 情况一

            ```
            <ul>
              <li>A</li>
              <li>B</li>
            </ul>
            
            <ul>
              <li>A</li>
              <li>B</li>
              <li>C</li>
            </ul>
            ```

            React 依次对比 A-A、B-B、空-C，发现 C 是新增的，最终会创建真实 C 节点插入页面。

         1. 情况二

            ```
            <ul>
              <li>B</li>
              <li>C</li>
            </ul>
            
            <ul>
              <li>A</li>
              <li>B</li>
              <li>C</li>
            </ul>
            ```

            React 对比 B-A，会删除 B 文本新建 A 文本；对比 C-B，会删除 C 文本，新建 B 文本；（注意，并不是边对比边删除新建，而是把操作汇总到 patch 里再进行 DOM 操作。）对比空-C，会新建 C 文本。

            你会发现其实只需要创建 A 文本，保留 B 和 C 即可，为什么 React 做不到呢？

            因为 React 需要你加 key 才能做到：

            ```
            <ul>
              <li key="b">B</li>
              <li key="c">C</li>
            </ul>
            
            <ul>
              <li key="a">A</li>
              <li key="b">B</li>
              <li key="c">C</li>
            </ul>
            ```

            React 先对比 key 发现 key 只新增了一个，于是保留 b 和 c，新建 a。

         以上是 React 的 diff 算法（源码分析在下一节补充视频中，时长一小时，有能力者选看）。

         但面试官想听的可能是 Vue 的「双端交叉对比」算法：

         https://canyuegongzi.github.io/web/vue/3.html#updatechildren

         https://juejin.cn/post/6971622260490797069

         我就当复读机帮你捋一遍。
         
## 3.补充：React DOM diff 和 Vue DOM diff 的区别？

         先纠正之前的一个细节错误：
         
         错：我认为数组存储的是整棵树。
         
         对：其实数组存储的是拥有相同爸爸的一群子节点。


​         
​         
​         React DOM diff 和 Vue DOM diff 的区别：
​         
​         1. React 是从左向右遍历对比，Vue 是双端交叉对比。
​         
​         1. React 需要维护三个变量（有点扯），Vue 则需要维护四个变量。
​         
​         1. Vue 整体效率比 React 更高，举例说明：假设有 N 个子节点，我们只是把最后子节点移到第一个，那么
​         
​            1. React 需要进行借助 Map 进行 key 搜索找到匹配项，然后复用节点
​         
​            1. Vue 会发现移动，直接复用节点


​            
​         
​         附 React DOM diff 代码查看流程：
​         
​         1. 运行 `git clone ht``tps://github.com/facebook/react.git`
​         
​         1. 运行 `cd react; git switch 17.0.2`
​         
​         1. 用 VSCode 或 WebStorm 打开 react 目录
​         
​         1. 打开 `packages/react-reconciler/src/ReactChildFiber.old.js` 第 1274 行查看旧版代码，或打开 `packages/react-reconciler/src/ReactChildFiber.new.js` 第 1267 行查看新代码（实际上一样）
​         
​         1. 忽略所有警告和报错，因为 React JS 代码中有不是 JS 的代码
​         
​         1. 折叠所有代码
​         
​         1. 根据 React 文档中给出的场景反复在大脑中运行代码
​         
​            1. 场景0：单个节点，会运行到 reconcileSingleElement。接下来看多个节点的情况。
​         
​            1. 场景1：没 key，标签名变了，最终会走到 createFiberFromElement（存疑）
​         
​            1. 场景2：没 key，标签名没变，但是属性变了，最终走到 updateElement 里的 useFiber
​         
​            1. 场景3：有 key，key 的顺序没变，最终走到 updateElement
​         
​            1. 场景4：有 key，key 的顺序变了，updateSlot 返回 null，最终走到 mapRemainingChildren、updateFromMap 和 updateElement(matchedFiber)，整个过程较长，效率较低
​         
​         1. 代码查看要点：
​         
​            1. 声明不看（用到再看）
​         
​            1. if 先不看（但 if else 要看）
​         
​            1. 函数调用必看
​         
​         1. 必备快捷键：折叠所有、展开、向前、向后、查看定义

## 4.React 有哪些生命周期钩子函数？数据请求放在哪个钩子里？

React 的文档稍微有点乱，需要配合两个地方一起看才能记忆清楚：

https://reactjs.org/docs/react-component.html#the-component-lifecycle

https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

总得来说：

1. 挂载时调用 constructor，更新时不调用

1. 更新时调用 shouldComponentUpdate 和 getSnapshotBeforeUpdate，挂载时不调用

1. should... 在 render 前调用，getSnapshot... 在 render 后调用

1. 请求放在 componentDidMount 里，最好写博客，容易忘。

## 5.React 如何实现组件间通信

1. 父子组件通信：props + 函数

1. 爷孙组件通信：两层父子通信或者使用 Context.Provider 和 Context.Consumer

1. 任意组件通信：其实就变成了状态管理了

   1. Redux 

   1. Mobx

   1. Recoil

## 6.你如何理解 Redux？

1. 文档第一句话背下来：Redux 是一个状态管理库/状态容器。 

1. 把 Redux 的核心概念说一下：

   1. State

   1. Action = type + payload 荷载

   1. Reducer 

   1. Dispatch 派发

   1. Middleware

1. 把 ReactRedux 的核心概念说一下：

   1. connect()(Component)

   1. mapStateToProps

   1. mapDispatchToProps

1. 说两个常见的中间件 redux-thunk redux-promise

想深入了解可以看我的免费视频课：

https://www.bilibili.com/video/BV1dm4y1R7RK/?from=search&seid=8579266903295629745&spm_id_from=333.337.0.0

## 7.什么是高阶组件 HOC？

参数是组件，返回值也是组件的函数。什么都能做，所以抽象问题就具体回答。

举例说明即可：

1. React.forwardRef

1. ReactRedux 的 connect

1. ReactRouter 的 withRouter
2. 参考阅读: https://juejin.cn/post/6940422320427106335#heading-0

# 8.React Hooks 如何模拟组件生命周期？

1. 模拟 componentDidMount

1. 模拟 componentDidUpdate

1. 模拟 componentWillUnmount

代码示例如下：

```
import { useEffect,useState,useRef } from "react";
import "./styles.css";

export default function App() {
  const [visible, setNextVisible] = useState(true)
  const onClick = ()=>{
    setNextVisible(!visible)
  }
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      {visible ? <Frank/> : null}
      <div>
        <button onClick={onClick}>toggle</button>
        </div>
     
    </div>
  );
}

function Frank(props){
  const [n, setNextN] = useState(0)
  const first = useRef(true)
  useEffect(()=>{
    if(first.current === true ){
      return
    }
    console.log('did update')
  })
  useEffect(()=>{
    console.log('did mount')
    first.current = false
    return ()=>{
      console.log('did unmount')
    }
  }, [])
  
  const onClick = ()=>{
    setNextN(n+1)
  }
  return (
    <div>Frank
      <button onClick={onClick}>+1</button>
    </div>
  )
}
```

完。

# 五、Node.js

## 1.Node.js 的 EventLoop 是什么？

### **背景知识**

https://juejin.cn/post/6844903582538399752

Node.js 将各种函数（也叫任务或回调）分成至少 6 类，按先后顺序调用，因此将时间分为六个阶段：

1. timers 阶段（setTimeout）

1. I/O callbacks 该阶段不用管

1. idle, prepare 该阶段不用管

1. poll 轮询阶段，停留时间最长，可以随时离开。

   1. 主要用来处理 I/O 事件，该阶段中 Node 会不停询问操作系统有没有文件数据、网络数据等

   1. 如果 Node 发现有 timer 快到时间了或者有 setImmediate 任务，就会主动离开 poll 阶段

1. check 阶段，主要处理 setImmediate 任务

1. close callback 该阶段不用管

Node.js 会不停的从 1 ~ 6 循环处理各种事件，这个过程叫做事件循环（Event Loop）。

### **nextTick**

process.nextTick(fn) 的 fn 会在什么时候执行呢？

在 Node.js 11 之前，会在每个阶段的末尾集中执行（俗称队尾执行）。

在 Node.js 11 之后，会在每个阶段的任务间隙执行（俗称插队执行）。

浏览器跟 Node.js 11 之后的情况类似。可以用 window.queueMicrotask 模拟 nextTick。

### Promise

Promise.resolve(1).then(fn) 的 fn 会在什么时候执行？

这要看 Promise 源码是如何实现的，一般都是用 process.nextTick(fn) 实现的，所以直接参考 nextTick。

### async / await 

这是 Promise 的语法糖，所以直接转为 Promise 写法即可。



面试题1：

```
setTimeout(() => {
  console.log('setTimeout')
})

setImmediate(() => {
  console.log('setImmediate')
})
// 在 Node.js 运行会输出什么？
// A setT setIm
// B setIm setT
// C 出错
// D A 或 B
// 在浏览器执行会怎样？
```



面试题2：

```
async function async1(){
    console.log('1')                   // 2
    async2().then(()=>{
      console.log('2')
    })
    
}
async function async2(){
    console.log('3')                   // 3
}
console.log('4')                        // 1
setTimeout(function(){
    console.log('5') 
},0)  
async1();
new Promise(function(resolve){
    console.log('6')                    // 4
    resolve();
}).then(function(){
    console.log('7')
})
console.log('8')                           // 5  
//4 1 3 6 8 2 7 5 
```

🤹

## 2.浏览器里的微任务和任务是什么？

浏览器中并不存在宏任务，宏任务（Macrotask）是 Node.js 发明的术语。

浏览器中只有任务（Task）和微任务（Microtask）。

1. 使用 script 标签、setTimeout 可以创建任务。

1. 使用 Promise#then、window.queueMicrotask、MutationObserver、Proxy 可以创建微任务。

执行顺序是怎样的呢？

微任务会在任务间隙执行（俗称插队执行）。

⚠️

注意，微任务不能插微任务的队，微任务只能插任务的队。

面试题：https://www.zhihu.com/question/495934384

```
// next = [0, 4x, 1, 2, 3, 5, 6]
Promise.resolve()
	.then(() => {
	    console.log(0);
	    return Promise.resolve('4x');
	})
	
	.then((res) => {console.log(res)})
	
Promise.resolve().then(() => {console.log(1);})
                 .then(() => {console.log(2);}, ()=>{console.log(2.1)})
                 .then(() => {console.log(3);})
                 .then(() => {console.log(5);})
                 .then(() => {console.log(6);})

	 
```

## 3.express.js 和 koa.js 的区别是什么？

1. 中间件模型不同：express 的中间件模型为线型，而 koa 的为U型（洋葱模型）。

1. 对异步的处理不同：express 通过回调函数处理异步，而 koa 通过generator 和 async/await 使用同步的写法来处理异步，后者更易维护，但彼时 Node.js 对 async 的兼容性和优化并不够好，所以没有流行起来。

1. 功能不同：express 包含路由、渲染等特性，而 koa 只有 http 模块。

总得来说，express 功能多一点，写法烂一点，兼容性好一点，所以当时更流行。虽然现在 Node.js 已经对 await 支持得很好了，但是 koa 已经错过了风口。

不过 express 和 koa 的作者都是 TJ 大神。

# 六、工程化	 

## 常见 loader 和 plugin 有哪些？二者的区别是什么？

### 常见 loader 

在 webpack 文档里写了：https://webpack.js.org/loaders/

你可以记住：

1. `babel-loader` 把 JS/TS 变成  JS

1. `ts-loader` 把 TS 变成 JS，**并提示类型错误**

1. `markdown-loader` 把 markdown 变成 html

1. `html-loader` 把 html 变成 JS 字符串

1. `sass-loader` 把 SASS/SCSS 变成 CSS

1. `css-loader` 把 CSS 变成 JS 字符串

1. `style-loader` 把 JS 字符串变成 style 标签

1. `postcss-loader` 把 CSS 变成更优化的 CSS

1. `vue-loader` 把单文件组件（SFC）变成 JS 模块

1. `thread-loader` 用于多进程打包

### 常见 plugin

也在 webpack 文档里写了：

你可以记住这些：

1. `html-webpack-plugin` 用于创建 HTML 页面并自动引入 JS 和 CSS

1. `clean-webpack-plugin` 用于清理之前打包的残余文件

1. `mini-css-extract-plugin` 用于将 JS 中的 CSS 抽离成单独的 CSS 文件

1. `SplitChunksPlugin` 用于代码分包（Code Split）

1. `DllPlugin` + `DllReferencePlugin` 用于避免大依赖被频繁重新打包，大幅降低打包时间

   https://segmentfault.com/a/1190000016567986

2. `eslint-webpack-plugin` 用于检查代码中的错误

3. `DefinePlugin` 用于在 webpack config 里添加全局变量

4. `copy-webpack-plugin` 用于拷贝静态文件到 dist

5. ### 二者的区别

   - loader 是文件加载器（这句废话很重要）

     - 功能：能够对文件进行编译、优化、混淆（压缩）等，比如 babel-loader / vue-loader

     - 运行时机：在创建最终产物之前运行

   - plugin 是 webpack 插件（这句废话也很重要）

     - 功能：能实现更多功能，比如定义全局变量、Code Split、加速编译等

     - 运行时机：在整个打包过程（以及前后）都能运行

# 七、算法

## 1.大数相加

题目

```
const add = (a, b) => {
  ...
  return sum
}

console.log(add("11111111101234567","77777777707654321"))
console.log(add("911111111101234567","77777777707654321"))
```

答案

```
const add = (a, b) => {
  const maxLength = Math.max(a.length, b.length)
  let overflow = false
  let sum = ''
  for(let i = 1; i <= maxLength; i++){
    const ai = a[a.length-i] || '0'
    const bi = b[b.length-i] || '0'
    let ci = parseInt(ai) + parseInt(bi) + (overflow ? 1 : 0)
    overflow = ci >= 10
    ci = overflow ? ci - 10 : ci
    sum = ci + sum 
  }
  sum = overflow ? '1' + sum : sum
  return sum
}

console.log(add("11111111101234567","77777777707654321"))
console.log(add("911111111101234567","77777777707654321"))
```

15位加速版：

```
const add = (a, b) => {
  const maxLength = Math.max(a.length, b.length)
  let overflow = false
  let sum = ''
  for(let i = 0; i < maxLength; i+=15){
    const ai = a.substring(a.length-i -15, a.length-i) || '0'
    const bi = b.substring(b.length-i -15, b.length-i) || '0'
    let ci = parseInt(ai) + parseInt(bi)
    overflow = ci > 999999999999999 // 15 个 9
    ci = overflow ? ci - (999999999999999+1) : ci
    sum = ci + sum 
  }
  sum = overflow ? '1' + sum : sum
  return sum
}

console.log(add("11111111101234567","77777777707654321"))
console.log(add("911111111101234567","77777777707654321"))
```

其他思路：

1. 转为数组，然后倒序，遍历

1. 使用队列，使用 while 循环

可以自行搜索。

## 2.两数之和
题目

```
const numbers = [2,7,11,15]
const target = 9
const twoSum = (numbers, target) => {
  // ...
}
console.log(twoSum(numbers, target))
// [0, 1] 或 [1, 0]

// 出题者保证
// 1. numbers 中的数字不会重复
// 2. 只会存在一个有效答案
```

答案

```
const numbers = [2,7,11,15]
const target = 9
const twoSum = (numbers, target) => {
  const map = {}
  for(let i = 0; i < numbers.length; i++){
    const number = numbers[i]
    const number2 = target - number
    if(number2 in map){
      const number2Index = map[number2]
      return [i, number2Index]
    } else {
      map[number] = i
    }
  }
  return []
}
console.log(twoSum(numbers, target))
```

上面是给菜鸟看的，所以有多余的中间变量，可以删掉。

## 3.无重复最长子串的长度
题目

https://leetcode.cn/problems/longest-substring-without-repeating-characters/

```
const lengthOfLongestSubstring = (str) => {
  //...
}

console.log(lengthOfLongestSubstring("abcabcbb"))
// 3
```

答案：滑动窗口法

我称之为「两根手指法」。

```
var lengthOfLongestSubstring = function(s){
  if(s.length <= 1) return s.length
  let max = 0
  let p1 = 0
  let p2 = 1
  while(p2 < s.length) {
    let sameIndex = -1
    for(let i = p1; i < p2; i++){
      if(s[i] === s[p2]){
        sameIndex = i
        break
      }
    }
    let tempMax 
	  if( sameIndex >= 0){
	    tempMax = p2 - p1
	    p1 = sameIndex + 1
	  }else{
	    tempMax = p2 - p1 + 1
	  }
	  if(tempMax > max){
	    max = tempMax
	  }
    p2 += 1
  }
  
  return max
}
```

使用 map 加速：

```
var lengthOfLongestSubstring = function(s) {
  if (s.length <= 1)
    return s.length
  let max = 0
  let p1 = 0
  let p2 = 1
  const map = {}
  map[s[p1]] = 0
  while (p2 < s.length) {
    let hasSame = false
    if(s[p2] in map){
      hasSame = true
      if(map[s[p2]] >= p1){
          p1 = map[s[p2]] + 1
      }
    }
    map[s[p2]] = p2
    let tempMax = p2 - p1 + 1
    if(tempMax > max) max = tempMax
    p2 += 1
  }
  return max
};
```

你会发现，加速失败，可能是 JS 的问题。

改用 new Map() 试试：

```
var lengthOfLongestSubstring = function(s) {
  if (s.length <= 1)
    return s.length
  let max = 0
  let p1 = 0
  let p2 = 1
  const map = new Map()
  map.set(s[p1], 0)
  while (p2 < s.length) {
    let hasSame = false
    if(map.has(s[p2])){
      hasSame = true
      if(map.get(s[p2]) >= p1){
          p1 = map.get(s[p2]) + 1
      }
    }
    map.set(s[p2],p2)
    let tempMax = p2 - p1 + 1
    if(tempMax > max) max = tempMax
    p2 += 1
  }
  return max
};
```

你会发现，加速失败，这应该还是 JS 的问题。


# 八、答题技巧

## 抽象问题答具体，具体问题可抽象

举例一：

> 你如何理解设计模式？

你应该把问题转变成

> 我是如何理解发布订阅模式、工厂模式、builder 模式的

举例二：

> 你平时是如何学习编程的？

你说完看书、看博客、看视频和逛论坛是不是就没得说了？可以抽象一点，比如

> 我主要通过「输入」、「转化」和「输出」来学习。 「输入」是指阅读别人分享的知识，比如看博客、看书。 「转化」是指把知识消化之后变成自己的积累，用自己的知识体系重新阐述一遍新学的概念。 「输出」是指把自己的理解以博客、视频的形式分享给别人。

## 学会「总-分-总」叙事

听到问题之后，如果觉得问题很复杂，可以先跟面试官确认一下：

> 你问的是 XXX 吗？

目的有二：

1. 确保自己不要偏题

1. 留给自己一些时间组织语言

然后你可以用这句话开头：

> 我觉得这个问题可以从两方面考虑 一是…… 二是……

如果你说着说着发现新的点，可以接着说

> 对了，还有一点可以补充……

最后你可以结尾：

> 我平时就是从这三点来解决类似问题的

这就是「总-分-总」，这种叙事的好处是让你显得思路清晰。

## 学会放弃，加个但是

如果某个知识点你完全不会，可以直接说「没接触过」。

但是，你一定要加一个「但是」或者「因为」：

> 因为我平时主要关注的是 XXX 方向，所以你能不能问这个方向的题目呢？

强行把话题转向自己擅长的领域。

如果你没有擅长的领域，就当我没说……

## 不要冷场超过三秒钟

听完题目如果没思路千万不要闷头想，这样会让气氛变得非常焦灼。

想不到说什么可以向面试官确认或者求面试官给提示。

# 九、TS

## 1.TS 和 JS 的区别是什么？有什么优势？

1. 语法层面：TypeScript = JavaScript + Type（TS 是 JS 的超集）

1. 执行环境层面：浏览器、Node.js 可以直接执行 JS，但不能执行 TS（Deno 可以执行 TS）

1. 编译层面：TS 有编译阶段，JS 没有编译阶段（只有转译阶段和 lint 阶段）

1. 编写层面：TS 更难写一点，但是**类型更安全**

1. 文档层面：TS 的代码写出来就是文档，IDE 可以完美**提示**。JS 的提示主要靠 TS

其他……自己搜一下博客

## 2.any、unknown、never 的区别是什么？

### any V.S. unknown

二者都是顶级类型（top type），任何类型的值都可以赋值给顶级类型变量：

```
let foo: any = 123; // 不报错
let bar: unknown = 123; // 不报错
```

但是 unknown 比 any 的类型检查更严格，any 什么检查都不做，unknown 要求先收窄类型：

```
const value: unknown = "Hello World";
const someString: string = value; 
// 报错：Type 'unknown' is not assignable to type 'string'.(2322)
const value: unknown = "Hello World";
const someString: string = value as string; // 不报错
```

如果改成 any，基本在哪都不报错。所以能用 unknown 就优先用 unknown，类型更安全一点。

### never

never 是底类型，表示不应该出现的类型，这里有一个[尤雨溪给出的例子](https://www.zhihu.com/question/354601204/answer/888551021)：

```
interface A {
  type: 'a'
}

interface B {
  type: 'b'
}

type All = A | B

function handleValue(val: All) {
  switch (val.type) {
    case 'a':
      // 这里 val 被收窄为 A
      break
    case 'b':
      // val 在这里是 B
      break
    default:
      // val 在这里是 never
      const exhaustiveCheck: never = val
      break
  }
}
```

现在你应该理解什么是「不应该出现的类型」了吧。

## 3.type 和 interface 的区别是什么？

官方给出的[文档说明](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)：

1. 组合方式：interface 使用 extends 来实现继承，type 使用 & 来实现联合类型。

1. 扩展方式：interface 可以重复声明用来扩展，type 一个类型只能声明一次

1. 范围不同：type 适用于基本类型，interface 一般不行。

1. 命名方式：interface 会创建新的类型名，type 只是创建类型别名，并没有新创建类型。

其他……建议搜一下博客。

## 4.TS 工具类型 Partial、Required、Readonly、Exclude、Extract、Omit、ReturnType 的作用和实现？

1. 将英文翻译为中文。

   1. Partial 部分类型

   1. Required 必填类型

   1. Readonly 只读类型

   1. Exclude 排除类型

   1. Extract 提取类型

   1. Pick/Omit 排除 key 类型

   1. ReturnType 返回值类型

1. 举例说明每个工具类型的用法。

